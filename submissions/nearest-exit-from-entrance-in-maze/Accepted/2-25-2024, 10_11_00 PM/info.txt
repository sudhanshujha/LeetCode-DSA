{"id":1185938678,"question_id":2038,"lang":"java","lang_name":"Java","time":"1 month, 2 weeks","timestamp":1708879260,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1185938678/","is_pending":"Not Pending","title":"Nearest Exit from Entrance in Maze","memory":"45.1 MB","code":"import java.util.*;\n\n// using djikstra\nclass Solution {\n    public int nearestExit(char[][] maze, int[] entrance) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\n        \n        // Initialize distances array to store shortest distances from entrance to each cell\n        int[][] distances = new int[rows][cols];\n        for (int[] row : distances) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        \n        // Initialize priority queue to store cells based on their distances from the entrance\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // {row, col, distance}\n        pq.offer(new int[]{entrance[0], entrance[1], 0}); // Add entrance to the priority queue\n        distances[entrance[0]][entrance[1]] = 0; // Set distance to entrance as 0\n        \n        while (!pq.isEmpty()) {\n            int[] cell = pq.poll();\n            int x = cell[0];\n            int y = cell[1];\n            int distance = cell[2];\n            \n            // Explore neighbors in all four directions\n            for (int[] dir : directions) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                \n                // Check if the neighbor is within the maze bounds and is an empty cell\n                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && maze[newX][newY] == '.') {\n                    // Update distance if a shorter path is found\n                    if (distance + 1 < distances[newX][newY]) {\n                        distances[newX][newY] = distance + 1;\n                        pq.offer(new int[]{newX, newY, distance + 1});\n                        \n                        // If the exit is reached and it's not the entrance, return the distance\n                        if ((newX == 0 || newX == rows - 1 || newY == 0 || newY == cols - 1) && (newX != entrance[0] || newY != entrance[1])) {\n                            return distances[newX][newY];\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1; // No exit found\n    }\n}\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"nearest-exit-from-entrance-in-maze","has_notes":false,"flag_type":1}