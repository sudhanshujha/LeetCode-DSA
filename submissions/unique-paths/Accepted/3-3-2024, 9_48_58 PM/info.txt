{"id":1192784451,"question_id":62,"lang":"java","lang_name":"Java","time":"1 month, 1 week","timestamp":1709482738,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1192784451/","is_pending":"Not Pending","title":"Unique Paths","memory":"40.3 MB","code":"// space optimisation\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        // Initialize the DP array with 1, as there is only one way to reach any cell in the first row\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        \n        // Iterate over each row starting from the second row\n        for (int i = 1; i < m; i++) {\n            // Iterate over each column starting from the second column\n            for (int j = 1; j < n; j++) {\n                // The number of paths to reach the current cell is the sum of the paths from above and from the left\n                dp[j] += dp[j - 1];\n            }\n        }\n        \n        // The value at dp[n - 1] represents the number of unique paths to reach the bottom-right corner of the grid\n        return dp[n - 1];\n    }\n}\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"unique-paths","has_notes":false,"flag_type":1}