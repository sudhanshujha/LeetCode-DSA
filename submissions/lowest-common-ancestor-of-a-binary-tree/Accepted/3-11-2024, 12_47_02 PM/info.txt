{"id":1200298986,"question_id":236,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1710141422,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1200298986/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"44 MB","code":"class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        List<TreeNode> pathToP = new ArrayList<>();\n        List<TreeNode> pathToQ = new ArrayList<>();\n        pre(root, p, pathToP);\n        pre(root, q, pathToQ);\n        int n = Math.min(pathToP.size(), pathToQ.size());\n        int i = 0;\n        while (i < n) {\n            if (pathToP.get(i) != pathToQ.get(i))\n                return pathToP.get(i - 1);\n            i++;\n        }\n        return pathToP.get(n - 1);\n    }\n\n    public static void pre(TreeNode root, TreeNode node, List<TreeNode> list) {\n        if (root == null)\n            return;\n        list.add(root);\n        if (root == node)\n            return;\n        // search node\n        // store path from root to the node in list\n        pre(root.left, node, list);\n        if (list.get(list.size() - 1) != node) // If the node is not found in the left subtree\n            pre(root.right, node, list);\n\n        // don't miss removing last added element during backtracking\n        if (list.get(list.size() - 1) != node)\n            list.remove(list.size() - 1);\n    }\n}\n","compare_result":"11111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":true,"flag_type":1}